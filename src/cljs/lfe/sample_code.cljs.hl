(ns lfe.sample-code
    (:require [hoplon.reveal :refer [highlight]]))


(defn get-page-13 []
  (highlight
    ;;{{
    apply[fn;x;a] =
         [atom[fn] -> [eq[fn;CAR] -> caar[x];
                      eq[fn;CDR] -> cdar[x];
                      eq[fn;CONS] -> cons[car[x];cadr[x]];
                      eq[fn;ATOM] -> atom[car[x]];
                      eq[fn;EQ] -> eq[car[x];cadr[x]];
                      T -> apply[eval[fn;a];x;a]];
         eq[car[fn];LAMBDA] -> eval[caddr[fn];parlis[cadr[fn];x;a]];
         eq[car[fn];LABEL] -> apply[caddr[fn];x;cons[cons[cadr[fn];
                                   caddr[fn]];a]]]

    eval[e;a] = [atom[e] -> cdr[assoc[e;a]];
         atom[car[e]] ->
          [eq[car[e],QUOTE] -> cadr[e];
          eq[car[e];COND] -> evcon[cdr[e];a];
          T -> apply[car[e];evlis[cdr[e];a];a]];
          T -> apply[car[e];evlis[cdr[e];a];a]]

    evcon[c;a] = [eval[caar[c];a] -> eval[cadar[c];a];
          T -> evcon[cdr[c];a]]

    evlis[m;a] = [null[m] -> NIL;
        T -> cons[eval[car[m];a];evlis[cdr[m];a]]]
    ;;}}
    ))

(defn get-parens-quote []
  (highlight :class "lisp"
    ;;{{
    (with more.
          (an English
              (but
                (with fewer parentheses
                      (a Lisp
                         (I think is not
                            (What the world needs)))))))
    ;;}}
    ))

(defn church-numerals []
  (highlight :class "lisp"
    ;;{{
    (defun zero ()
      (lambda (s)
        (lambda (x) x)))

    (defun one ()
      (lambda (s)
        (lambda (x)
          (funcall s x))))

    (defun two ()
      (lambda (s)
        (lambda (x)
          (funcall s
            (funcall s x)))))
    ;;}}
    ))

(defn async-http []
  (highlight :class "lisp"
    ;;{{
    (defun get-page (url)
      "Make a single HTTP request."
      (let* ((method 'get)
             (headers ())
             (request-data (tuple url headers))
             (http-options ())
             (request-options (list (tuple 'sync 'false))))
        (: httpc request method request-data http-options request-options)
        (receive
          ((tuple 'http (tuple request-id (tuple 'error reason)))
           (: io format '"Error: ~p~n" (list reason)))
          ((tuple 'http (tuple request-id result))
           (: io format '"Result: ~p~n" (list result))))))
    ;;}}
    ))

(defn messenger []
  (highlight :class "lisp"
    ;;{{
      (defmodule messenger-back
       (export all))

      (defun print-result ()
        (receive
          ((tuple pid msg)
            (: io format '"Received message: '~s'~n" (list msg))
            (: io format '"Sending message to process ~p ...~n" (list pid))
            (! pid (tuple msg))
            (print-result))))

      (defun send-message (calling-pid msg)
        (let ((spawned-pid (spawn 'messenger-back 'print-result ())))
          (! spawned-pid (tuple calling-pid msg))))
    ;;}}
    ))

(defn erlang-lfe-macros []
  (highlight
    ;;{{
    Macs = [['defmacro',Make,fds,
             ['let',[[def,[list|Defs]]],
              ?BQ([tuple,?Q(Name),?UQ_S([Fu,fds,def])])]],
            ['defmacro',Match,fds,
             ['let',[[def,[list|lists:duplicate(length(Fields),?Q('_'))]]],
              ?BQ([tuple,?Q(Name),?UQ_S([Fu,fds,def])])]],
            ['defmacro',Test,[rec],
              ?BQ(['is_record',?UQ(rec),?Q(Name),length(Fields)+1])],
            ...
    ;;}}
    ))

(defn numbers []
  (highlight :class "lisp"
    ;;{{
      > (+ 1 2 3 4 5 6)
      21
      > (- 6 21)
      15
      > (/ 36 7)
      5.142857142857143
      > (+ #b101010 #o52 #x2a #36r16)
      168
      > (* 42 4)
      168
      > (: erlang integer_to_list (+ #b1001 #b100 #b10) 2)
      "1111"
      > (div 11 2)
      5
      > (rem 11 2)
      1
    ;;}}
    ))

(defn atoms-and-strings []
  (highlight :class "lisp"
    ;;{{
      > 'Vogon
      Vogon
      > '|and now with hyperspace bypasses|
      |and now with hyperspace bypasses|
      > '"Don't Panic."
      "Don't Panic."
      > (list 68 111 110 39 116 32 80 97 110 105 99 46)
      "Don't Panic."
    ;;}}
    ))

(defn bit-pack []
  (highlight :class "lisp"
    ;;{{
      > (set red 2)
      2
      > (set green 61)
      61
      > (set blue 20)
      20
      > (binary
          (red (size 5))
          (green (size 6))
          (blue (size 5)))
      #B(23 180)
    ;;}}
    ))

(defn bit-unpack []
  (highlight :class "lisp"
    ;;{{
      > (let (((binary (r (size 5)) (g (size 6)) (b (size 5)))
               #b(23 180)))
             (: io format '"~p ~p ~p~n" (list r g b)))
      2 61 20
      ok
      ;;}}
      ))

(defn lists-1 []
  (highlight :class "lisp"
    ;;{{
      > (list 1 3 9 27)
      (1 3 9 27)
      > '(1 3 9 27)
      (1 3 9 27)
      > (: erlang length '(1 2 3 4 5 6 7))
      7
      > (: lists append '(1 2) '(3 4))
      (1 2 3 4)
      > (: lists append (list '(1 2) '(3 4) '(5 6)))
      (1 2 3 4 5 6)
      ;;}}
      ))

(defn lists-2 []
  (highlight :class "lisp"
    ;;{{
      > (car '(1 2 3 4 5 6))
      1
      > (cdr '(1 2 3 4 5 6))
      (2 3 4 5 6)
      > (cadr '(1 2 3 4 5 6))
      2
      > (cddr '(1 2 3 4 5 6))
      (3 4 5 6)
      > (cons '(1 2 3) '(4 5 6))
      ((1 2 3) 4 5 6)
      ;;}}
      ))

(defn records-1 []
  (highlight :class "lisp"
    ;;{{
      (defrecord person
        name
        address
        age)
      ;;}}
  ))

(defn records-2 []
  (highlight :class "lisp"
    ;;{{
      > (set ford
          (make-person name '"Ford Prefect"
                       address '"Betelgeuse Seven"
                       age 234))
      #(person "Ford Prefect" "Betelgeuse Seven" 234)
      ;;}}
  ))

(defn records-3 []
  (highlight :class "lisp"
    ;;{{
      > (person-name ford)
      "Ford Prefect"
      > (set ford
          (set-person-age ford 244))
      #(person "Ford Prefect" "Betelgeuse Seven" 244)
      > (person-age ford)
      244
      ;;}}
  ))

(defn patterns-1 []
  (highlight :class "lisp"
    ;;{{
      > (let (((tuple len status data) #(8 ok "Trillian")))
             (list len status data))
      (8 ok "Trillian")
    ;;}}
    ))

(defn patterns-2 []
  (highlight :class "lisp"
    ;;{{
      > (case data
          ((tuple len 'ok msg)
            (: io format '"~s seems good.~n" (list msg)))
          ((tuple len 'err msg)
            (: io format '"There's a problem with ~s.~n" (list msg)))
          ((tuple len 'warn msg)
            (: io format '"Be careful of ~s.~n" (list msg))))
      Be careful of Arthur.
      ok
    ;;}}
    ))

(defn patterns-3 []
  (highlight :class "lisp"
    ;;{{
      (cond ((?= (tuple len 'ok msg) data)
             (: io format '"~s seems good.~n" (list msg)))
            ((?= (tuple len 'err msg) data)
             (: io format '"There's a problem with ~s.~n" (list msg)))
            ((?= (tuple len 'warn msg) data)
             (: io format '"Be careful of ~s.~n" (list msg))))
    ;;}}
    ))

(defn patterns-4 []
  (highlight :class "lisp"
    ;;{{
      (defun safety-check
        (('ok msg)
          (: io format '"~s seems good.~n" (list msg)))
        (('warn msg)
          (: io format '"There's a problem with ~s.~n" (list msg)))
        (('crit msg)
          (: io format '"Be careful of ~s.~n" (list msg))))
    ;;}}
    ))

(defn patterns-5 []
  (highlight :class "lisp"
    ;;{{
      (defun safety-check ()
        (receive
          ((tuple 'ok item)
            (: io format '"~s is safe to approach.~n" (list item))
            (safety-check))
          ((tuple 'warn item)
            (: io format '"Approach ~s with extreme caution.~n" (list item))
            (safety-check))
          ((tuple 'crit item)
            (: io format '"Withdraw from ~s immediately!~n" (list item))
            (safety-check))))
    ;;}}
    ))

(defn macros-1 []
  (highlight :class "lisp"
    ;;{{
      (defmacro deftest arg
        (let ((name (car arg))
              (body (cdr arg)))
          `(defun ,(list_to_atom (++ (atom_to_list name) '"_test")) ()
             ,@body)))
    ;;}}
    ))

(defn macros-2 []
  (highlight :class "lisp"
    ;;{{
      (defun is-equal_test ()
        (is-equal 1 1)
        (is-equal 1 (+ 1 0))
        (is-equal 1 (- 2 1)))
    ;;}}
    ))

(defn macros-3 []
  (highlight :class "lisp"
    ;;{{
      (deftest is-equal
        (is-equal 1 1)
        (is-equal 1 (+ 1 0))
        (is-equal 1 (- 2 1)))
    ;;}}
    ))

(defn install-lfe []
  (highlight :class "bash"
    ;;{{
      $ cd ~/lab
      $ git clone https://github.com/rvirding/lfe.git
      $ cd lfe && make compile
      $ ERL_LIBS=you_lib_path make install
      $ cp bin/* /usr/local/bin/
    ;;}}
    ))

(defn install-lfetool []
  (highlight :class "bash"
    ;;{{
      $ cd ~/
      $ curl -o ./lfetool https://raw.github.com/lfe/lfetool/master/lfetool
      $ bash ./lfetool install /usr/local/bin
      $ rm ./lfetool
    ;;}}
    ))

(defn update-lfetool []
  (highlight :class "bash"
    ;;{{
      $ lfetool update
      % Total  % Received % Xferd  Average Speed   Time    Time    Time  Current
                                   Dload   Upload  Total   Spent   Left  Speed
    100 11895  100 11895  0     0  19835      0 --:--:-- --:--:-- --:--:-- 61632

    Updated lfetool at /usr/local/bin/lfetool.
    ;;}}
    ))

(defn create-a-script []
  (highlight :class "bash"
    ;;{{
      $ lfetool new script fibo
      $ ./fibo 42
      factorial 42 = 1405006117752879898543142606244511569936384000000000
    ;;}}
    ))

(defn script-guts []
  (highlight :class "lisp"
    ;;{{
      #! /usr/bin/env lfescript
      ;; -*- mode: lfe -*-
      ;;! -smp enable -sname factorial -mnesia debug verbose
      (defun main
        (((list string))
          (try
            (let* ((n (list_to_integer string))
                    (f (fac n)))
               (: lfe_io format '"factorial ~w = ~w\n" (list n f)))
            (catch
              ((tuple _ _ _) (usage)))))
          ((_) (usage)))

      (defun fac
        ((0) 1)
        ((n) (* n (fac (- n 1)))))

      (defun usage ()
        (let ((script-name (: escript script_name)))
          (: lfe_io format '"usage: ~s <integer>\n" (list script-name))))
    ;;}}
    ))

(defn library-1 []
  (highlight :class "bash"
    ;;{{
      $ lfetool new library my-lib
      $ find my-lib -type f|egrep -v 'deps|.git|.beam'
      my-lib/ebin/my-lib.app
      my-lib/Makefile
      my-lib/package.exs
      my-lib/README.rst
      my-lib/rebar.config
      my-lib/src/my-lib.app.src
      my-lib/src/my-lib.lfe
      my-lib/test/my-lib_tests.lfe
    ;;}}
    ))

(defn library-2 []
  (highlight :class "lisp"
    ;;{{
    (defmodule my-lib
      (export all))

    (defun my-adder (x y)
      (+ x (+ y 1)))
    ;;}}
    ))

(defn library-3 []
  (highlight :class "lisp"
    ;;{{
      (defmodule my-lib_tests
        (export all))

      (include-lib "deps/lfeunit/include/lfeunit-macros.lfe")

      (deftest my-adder
        (is-equal 4 (: my-lib my-adder 2 2)))
    ;;}}
    ))

(defn service-1 []
  (highlight :class "bash"
    ;;{{
      $ lfetool new service my-svc
      $ find my-svc -type f|egrep -v 'deps|.git|.beam'
      my-svc/ebin/my-svc.app
      my-svc/Makefile
      my-svc/package.exs
      my-svc/README.rst
      my-svc/rebar.config
      my-svc/src/my-svc.app.src
      my-svc/src/my-svc_app.lfe
      my-svc/src/my-svc_server.lfe
      my-svc/src/my-svc_sup.lfe
      my-svc/test/my-svc_tests.lfe
    ;;}}
    ))

(defn service-2 []
  (highlight :class "lisp"
    ;;{{
      (defmodule my-svc_app
        (behaviour application)
        (export (start 2)
                (stop 1)))

      (defun start (type args)
        (let ((result (: my-svc_sup start_link)))
          (case result
            ((tuple 'ok pid)
              result)
            (_
              (tuple 'error result)))))

      (defun stop (state)
        'ok)
    ;;}}
    ))

(defn service-3 []
  (highlight :class "bash"
    ;;{{
      $ cd my-svc
      $ make shell
      ...
      LFE Shell V5.10.4 (abort with ^G)
      >
    ;;}}
    ))

(defn service-4 []
  (highlight :class "lisp"
    ;;{{
      > (: application start 'my-svc)
      ok
      > (: my-svc_server test-call '"Testing a call ...")
      Call: "Testing a call ..."
      ok
      > (: my-svc_server test-cast '"Testing a cast ...")
      ok
      Cast: "Testing a cast ..."
    ;;}}
    ))

(defn service-5 []
  (highlight :class "lisp"
    ;;{{
      (defun start_link ()
        (: gen_server start_link
           (tuple 'local (server-name)) (module-name) '() '()))

      (defun test-call (message)
        (: gen_server call
           (server-name) (tuple 'test message)))

      (defun test-cast (message)
        (: gen_server cast
           (server-name) (tuple 'test message)))
    ;;}}
    ))

(defn XXX []
  (highlight
    ;;{{
    ;;}}
    ))

(defn YYY []
  (highlight
    ;;{{
    ;;}}
    ))





